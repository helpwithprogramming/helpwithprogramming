Visit http://www.helpwithprogramming.com for help with this assignment, or any other programming work.

Project description::	Lab 3: Linked List
Due Date: November, 22nd 11:59pm (submission instructions)
Grade Value: 13% of total grade
Please, read all of this document before you start coding your program and pay special attention to the deductions section to avoid penalties.



1. Goals

The main goal for this lab is to write a C program using a linked list. We assume students are familiar with these concepts from lecture and can use them to implement the project. The class instructor and the TA welcome students to office hours where they can help students to learn these concepts.

2. Overview

In Lab2, you developed a C program that manipulates images, computes statistics from them, and performs several other basic image processing tasks using dynamic allocation to have the best efficiency in terms of the space required. For this Lab3, you will further improve the image structures and procedures of this text-based image processing system to use a linked list to store all images in the system. Besides adapting all previous tasks to consider the new data structure, two additional tasks are included in this project: image query and print list. The program terminate task is also updated to clear the entire memory space used by the linked list. The image query task will search for images in the linked list which are similar to a query image. The image distance function will be used to compute the dissimilarity between the query image and all images in the linked list. The images with a distance smaller than a certain threshold value will be reported as similar to the q! uery. The print list task will print the sizes of each image in the linked list. Note that Lab3 has all modules for a basic recognition system able to identify which South Park character (i.e., Cartman, Kyle, Stan, Kenny, and Butters) is portrayed in a query image.

3. Description

Initially, create a linked list, named imgLst, where each node contains as data member an array of unsigned characters. The linked list will be used to store a number of text-based images in the system. Hence, imgLst is a pointer to a node composed of a pointer to unsigned characters (the data member node->image) and a pointer to a node (the next member node->next). Therefore, if the current number of images in the system is n, the linked list imgLst contains n nodes. Each image in a data member of a node in imgLst consists of a dynamic array of exactly 2+vS*hS unsigned characters, where vS is the vertical size of the image and hS is the horizontal size of the image. The first two unsigned characters vSize and hSize in an image still correspond to integers that are associated with the vertical size vS and horizontal size hS of the image. Since unsigned character values may be seen as integers ranging from 0 to 255, the maximum size of an image is (255+1)*(255+1) and t! he minimum size is (0+1)*(0+1). After the first two unsigned characters, the next (vSize+1)*(hSize+1) unsigned characters in the array correspond to the pixels in the text-based image. Note that if vSize or hSize are less than 255, there will be no unused space in the image array since the image array will be dynamically allocated to the exact size of the image. You should keep track of the number n of images currently loaded in the system.
The data structure required to store our image database is the linked list imgLstSet of nodes containing arrays of unsigned characters and the current integer number n of images in the database. Figure 1 shows a two-dimensional image and the corresponding one-dimensional text-based version. Note that the two-dimensional coordinates of the image are from left-to-right and from bottom-to-top. Each row of the 2D image is placed from bottom-to-top in the 1D text-based image.


Figure 1. One-dimensional text-based image.
Figure 2 shows a linked list to store four (n = 4) text-based images. Hence, the list imgLst is composed of four nodes containing pointers to unsigned characters (images) and pointers to node (next). Each image is kept in the corresponding array of unsigned characters with 2+vS*hS cells. The first image has 4 cells since vS = (0+1) and hS = (1+1). The linked list imgLst is dynamically allocated to store exactly the n images as they are loaded or created in the system.

Figure 2. Linked list to store text-based images.
A menu screen should be displayed when the program starts and after any task is performed (except for the quit program task). The possible tasks in our text-based image processing system are: load image, remove image, print image, create average image, create horizontal derivative, create vertical derivative, compute histogram, search for digram, find local maxima, image descriptor, image distance, and quit program. In addition to those, we include the tasks query image and print list. These tasks are described in detailed below.
The format of the menu screen for the user is as follows:
*****OPTION*****MENU*****
L: Load image
R: Remove image
P: Print image
A: Average image
H: Horizontal derivative
V: Vertical derivative
T: compute hisTogram
D: search Digram
M: local Maxima
C: image desCriptor
N: image distance
U: qUery image
S: print liSt
Q: Quit program
*************************
After the menu screen is printed, the user is prompted with the message “Select an option: “ (ending with a space character). The user should type a single character (lowercase or uppercase), such that:
‘l’ or ‘L’ call the Load image task,
‘r’ or ‘R’ call the Remove image task,
‘p’ or ‘P’ call the Print image task,
‘a’ or ‘A’ call the create Average image task,
‘h’ or ‘H’ call the create Horizontal derivative task,
‘v’ or ‘V’ call the create Vertical derivative task,
‘t’ or ‘T’ call the compute hisTogram task,
‘d’ or ‘D’ call the search for Digram task,
‘m’ or ‘M’ call the find local Maxima task,
‘c’ or ‘C’ call the image desCriptor task,
‘n’ or ‘N’ call the image distaNce task,
‘u’ or ‘U’ call the qUery image task,
‘s’ or ‘S’ call the print liSt task, and
‘q’ or ‘Q’ call the Quit program task.
If the user types a non-existent option, the program prints the menu screen again. To avoid problems with input reading functions (e.g., scanf, getchar), you may also assume that the user will not enter a single new line character or a single whitespace character.
The load image task loads an image from a bitmap file to the linked list of images imgLst. Once the user selects the option ‘L’ in the menu screen, the system prompts the user with the message “Enter filename: “ (ending with a space) and reads the filename into a string of characters (i.e., char fileName[80];). You may assume that the user will enter a filename with less than 80 characters. We will provide you with one file (bitmap.c) that defines a function readImage. You will use the function readImage as a black box to read a bitmap image from a file in the same directory of your program. Make sure to have bitmap.c in the command line for compiling your code. For example, “gcc bitmap.c lab3.c –o lab3 -lm”. Do not include bitmap.c using an #include in lab3.c. The function readImage has two arguments which are the file name of the bitmap file and a reference to a pointer to unsigned characters. This pointer will receive the address of an array of unsigned char! acters allocated in the readImage function to store the text-based image. The number n of images in the system is incremented. The loading of the new image involves allocating a new node, loading the image into the data member of the new node (new_node->image) using the readImage function, and inserting the new node in the linked list imgLst. The new node must be inserted in the place where the image stored in the previous node has the size vS*hS lower than or equal to the size of the image in the new node. If this position is not the end of the linked list, then the image stored in the next node has the size greater than the size of the image in the new node. Note that the linked list is sorted according to the size of images stored in the nodes. The program should print the message “File filename has vS rows and hS columns” (ending with a newline character), where filename is the filename entered by the user, vS is the loaded image’s vSize+1, and hS is the loaded! image’s hSize+1. You may assume that the bitmap file is alw! ays pres ent in the directory and that the images loaded by readImage are not corrupted. After the load image task is executed, the menu screen is displayed again.
The remove image task deletes an image from the linked list imgLst. Once the user selects the option ‘R’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1, where n is the number of images currently in the database. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the remove image task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the number n of images in the system is decremented. The removing of an image involves traversing the linked list to find the previous node to the node corresponding to imgIndex, the next member of the previous node is adjusted to the next node of the removed node. You also must delete the memory space pointed by the data member of the removed node (i.e., the space allocated! for the text-based image) and the space pointed by the removed node itself. The program should print the message “Image imgIndex was removed” (ending with a newline character), where imgIndex is the index entered by the user. After the remove image task is executed, the menu screen is displayed again.

The print image task prints an image in the linked list imgLst to the screen. Once the user selects the option ‘P’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the print image task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the image in the node corresponding to imgIndex is printed to the screen. The first two characters vSize and hSize in the data member of the node determine the size (vSize+1)*(hSize+1) of the image. The image print out consists of (vSize+1) lines with (hSize+1) characters. Since the first row is at the bottom of the image, the characters in the image are printed in the following order: the (hSize+1) characters corresponding! to the last row (the one at the top) will be printed in the first line, the previous (hSize+1) characters (the penultimate row) will be printed in the second line, and so on (see Figure 3). Therefore, the last row to be printed in the screen is actually the first row in the image (i.e., the next (hSize+1) characters after the first two characters associated with the image sizes). Before printing in the screen, each image unsigned character is mapped into a printable ASCII character. The printable ASCII character is the one actually printed in the screen. The mapping from an image character to a printable ASCII character is performed according to the following array: map = {77, 77, 77, 78, 78, 72, 72, 72, 64, 64, 64, 35, 35, 66, 66, 66, 69, 69, 69, 75, 75, 75, 87, 87, 82, 82, 82, 109, 109, 109, 65, 65, 81, 81, 81, 85, 85, 85, 103, 103, 104, 104, 104, 107, 107, 107, 112, 112, 112, 113, 113, 52, 52, 52, 68, 68, 68, 70, 70, 98, 98, 98, 100, 100, 100, 121, 121, 56, 56, 56, 71, ! 71, 71, 110, 110, 119, 119, 119, 48, 48, 48, 54, 54, 54, 57, 5! 7, 79, 7 9, 79, 80, 80, 80, 83, 83, 84, 84, 84, 86, 86, 86, 88, 88, 89, 89, 89, 90, 90, 90, 97, 97, 102, 102, 102, 117, 117, 117, 36, 36, 36, 50, 50, 53, 53, 53, 73, 73, 73, 76, 76, 101, 101, 101, 115, 115, 115, 120, 120, 122, 122, 122, 51, 51, 51, 67, 67, 67, 74, 74, 118, 118, 118, 91, 91, 91, 93, 93, 106, 106, 106, 111, 111, 111, 114, 114, 116, 116, 116, 37, 37, 37, 43, 43, 49, 49, 49, 55, 55, 55, 99, 99, 99, 105, 105, 108, 108, 108, 38, 38, 38, 42, 42, 60, 60, 60, 62, 62, 62, 40, 40, 41, 41, 41, 61, 61, 61, 123, 123, 125, 125, 125, 47, 47, 47, 59, 59, 59, 63, 63, 92, 92, 92, 124, 124, 124, 34, 34, 58, 58, 58, 95, 95, 95, 33, 33, 44, 44, 44, 94, 94, 94, 45, 45, 45, 126, 126, 39, 39, 39, 46, 46, 46, 96, 96, 32, 32, 32}. The printable ASCII character prnChar corresponding to the image character imgChar is defined as “prnChar = map[imgChar];”. After the print image task is executed, the menu screen is displayed again.



Figure 3. The print image task.

The average image task averages the pixels of an image with their neighbors and creates a new average image to be included in imgSet. Once the user selects the option ‘A’ in the menu screen, the system prompts the user with the message “Enter image index: “(ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the average image task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the average image task creates a new average image with the same vertical size and same horizontal size of the image in the node cur_node corresponding to index imgIndex. The average image should be stored in the node new_node at the position that keeps the linked list sorted according to image size as described in the load image task and the number n of images in the! system is incremented. Note that the average image task performs similarly to the load image task with regards to including the new image in the image set. The average image is constructed by computing the average of the neighborhood for each pixel in the original image in the node associated with index imgIndex. In a two-dimensional image, the neighborhood of a pixel consists of the pixels immediately above, below, left, and right. Formally, the neighborhood of a pixel (r, c) is the set of pixels {(r-1, c), (r+1, c), (r, c-1), (r, c+1)} (see Figure 4). Since a text-based image is a one-dimensional array, we need to find the mappings from one-dimensional index to a two-dimensional index (and vice-versa). Given the values vSize and hSize of the image, a character cur_node->image[j] corresponds to a pixel (r, c) = (floor((j-2)/(hSize+1)), (j-2)%(hSize+1)) in the associated two-dimensional image. On the other hand, a pixel (r, c) corresponds to a character j = r*(hSize+1) ! + c + 2 in the one-dimensional representation. Using the mappi! ng betwe en 1D and 2D indices, the average image is constructed as follows: For each character j in the image, find the corresponding 2D coordinate (r, c). If either r = 0, c = 0, r = vSize, or c = hSize, then new_node->image[j] = cur_node->image [j]. Otherwise, new_node->image[j] = (cur_node->image[ja] + cur_node->image[jb] + cur_node->image[jl] + cur_node->image[jr])/4, where ja, jb, jl, jr are the 1D indices of the characters corresponding to the pixels (r-1, c), (r+1, c), (r, c-1), (r, c+1), respectively. When you compute the average, you will have to convert the characters into float numbers and use the floor function to convert the average back into an integer and, after that, into a character (using cast). The floor function is found in the math header file math.h which should be included. Do not forget to compile your code using the option –lm. After the average image task is executed, the menu screen is displayed again.


Figure 4. The neighborhood of a pixel in the average computation.
The horizontal derivative task computes the horizontal derivative of an image as a new image to be included in imgLst. Once the user selects the option ‘H’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the average image task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the horizontal derivative task creates a new image with the same size of the image in the node cur_node associated with index imgIndex. This new image should be stored in the node new_node at the position that keeps the linked list sorted according to image size as described in the load image task and the number n of images in the system is incremented. Note that the horizontal der! ivative task performs similarly to the load image task with regards to including the new image in the image set. Using the mapping between 1D and 2D indices defined above, the horizontal derivative image in new_node is constructed as follows: For each character j in the image, find the corresponding 2D coordinate (r, c). If either r = 0, c = 0, r = vSize, or c = hSize, then new_node->image[j] = cur_node->image[j]. Otherwise, new_node->image[j] = 255 - fabs(cur_node->image[jl] – cur_node->image[jr]), where jl, jr are the 1D indices of the characters corresponding to the pixels (r, c-1), (r, c+1), respectively. The fabs function is also in the math library. After the horizontal derivative task is executed, the menu screen is displayed again.
The vertical derivative task computes the vertical derivative of an image as a new image to be included in imgLst. Once the user selects the option ‘V’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the average image task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the vertical derivative task creates a new image with the same size of the image in the node cur_node associated with index imgIndex. This image should be stored in the node new_node at the position that keeps the linked list sorted according to image size as described in the load image task and the number n of images in the system is incremented. Note that the vertical derivative task! performs similarly to the load image task with regards to including the new image in the image set. Using the mapping between 1D and 2D indices defined above, the vertical derivative image in new_node is constructed as follows: For each character j in the image, find the corresponding 2D coordinate (r, c). If either r = 0, c = 0, r = vSize, or c = hSize, then new_node->image[j] = cur_node->image[j]. Otherwise, new_node->image[j] = 255 - abs(cur_node->image[ja] – cur_node->image[jb]), where ja, jb are the 1D indices of the characters corresponding to the pixels (r-1, c), (r+1, c), respectively. After the vertical derivative task is executed, the menu screen is displayed again.
The compute histogram task computes an array hist of 256 elements that corresponds to the histogram of an image in a node of imgLst. Each element hist[j] (0 £ j < 255) in the histogram array contains the number of times the character j appears in the image. Once the user selects the option ‘T’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the compute histogram task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the compute histogram task traverses the whole image in the node associated with index imgIndex and counts the number of appearances of each character in the image such that hist[j] contains the number of appearances of character j. Once! the histogram array is computed, the 256 elements of the array are printed in a single line with a single space after each number and no zeros preceding any number (except 0 itself). After the compute histogram task is executed, the menu screen is displayed again.
The search digram task finds all occurrences of a specific digram (a pair of consecutive characters) in an image in a node of imgLst. Once the user selects the option ‘D’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the search digram task is finished. Note that if the image array is empty, all indices will be invalid. After that, the system prompts the user with the message “Enter first character: “ (ending with a space) and reads an integer d1. The system prompts the user with the message “Enter second character: “ (ending with a space) and reads an integer d2. Both d1 and d2 should range from 0 to 255. Otherwise, the message “Error: Character out of range” (ending with a newline character) is p! rinted and the search digram task is finished. For a valid index imgIndex and valid characters d1 and d2, the search digram task traverses the whole image in the node cur_node associated with index imgIndex and finds the horizontal and vertical occurrences of the digram d1d2. Two horizontally consecutive pixels (r, c) and (r, c+1) are an occurrence of the digram d1d2 if and only if cur_node->image[jl] = d1 and cur_node->image[jr] = d2, where jl, jr are the 1D indices of the characters corresponding to the pixels (r, c), (r, c+1), respectively. Similarly, two vertically consecutive pixels (r, c) and (r+1, c) are an occurrence of the digram d1d2 if and only if cur_node->image[ja] = d1 and cur_node->image[jb] = d2, where ja, jb are the 1D indices of the characters corresponding to the pixels (r, c), (r+1, c), respectively. The occurrences of the digram d1d2 are displayed by printing the coordinates (r, c) of the first character d1 in the digram. The coordinates are! printed as “(r, c) “ with a space separating this coordin! ate from the next. Note that for each pixel, a digram may occur both horizontally and vertically. In this case, avoid printing duplicates of the same pixel coordinate. The digrams are printed in the order top-down first and left-right second. This way, digrams in the first row of the image are printed before digrams in the second row of the image. In the case of digrams in the same row, the digram in the leftmost column is printed first. All occurrences of the searched digram are printed in a single line. If the digram does not appear in the image, a blank line is printed. Note the boundary constraints to avoid traversing pixels outside the image. After the search digram task is executed, the menu screen is displayed again.
The local maxima task finds all occurrences of local maximum in an image in a node of imgLst. Once the user selects the option ‘M’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the local maxima task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the local maxima task traverses the whole image in the node cur_node associated with index imgIndex and finds the occurrences of local maximum. A pixel (r, c) is a local maximum if the associated character cur_node->image[j] is greater than all the characters in its neighborhood. Formally, cur_node->image[j] > cur_node->image[ja] and cur_node->image[j] > cur_node->image[jb] and cur_node! ->image[j] > cur_node->image[jl] and cur_node->image[j] > cur_node->image[jr], where ja, jb, jl, jr are the 1D indices of the characters corresponding to the pixels (r-1, c), (r+1, c), (r, c-1), (r, c+1), respectively. The occurrences of local maxima are displayed by printing the coordinates (r, c) of the character in the local maximum. The coordinates are printed as “(r, c) “ with a space separating this coordinate from the next. The local maxima are printed in the order top-down first and left-right second. This way, local maxima in the first row of the image are printed before local maxima in the second row of the image. In the case of local maxima in the same row, the local maximum in the leftmost column is printed first. All occurrences of local maxima are printed in a single line. If there is no local maximum in the image, a blank line is printed. Note the boundary constraints to avoid traversing pixels outside the image. After the local maxima t! ask is executed, the menu screen is displayed again.
The image descriptor task computes the descriptor of an image in a node of imgLst. Once the user selects the option ‘C’ in the menu screen, the system prompts the user with the message “Enter image index: “ (ending with a space) and reads an integer named imgIndex. imgIndex should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the image descriptor task is finished. Note that if the image array is empty, all indices will be invalid. For a valid index imgIndex, the image descriptor task computes the histogram hist of the image in the node cur_node associated with the index imgIndex. The histogram array hist is sorted in descending order. If two characters c1 and c2 have the same count k1 = k2 in the histogram, the character associated with the higher index precedes the character associated with the lower index. For example, if character 45 has 7 occurrences and character! 67 also has 7 occurrences, then character 67 precedes 45 in the sorted histogram. The 32 highest counts are printed as “(c, k) “ with a space separating each pair, where c is the integer index of the histogram corresponding to character c and k is the number of occurrences of character c in the image in the node cur_node (cur_node->image). All 32 elements of the descriptor are printed in a single line. After the image descriptor task is executed, the menu screen is displayed again.
The image distance task computes the distance between two images in nodes of imgLst. Once the user selects the option ‘N’ in the menu screen, the system prompts the user with the message “Enter first image index: “ (ending with a space) and reads an integer named imgIndex1. After that, the system prompts the user with the message “Enter second image index: “ (ending with a space) and reads an integer named imgIndex2. imgIndex1 and imgIndex2 should range from 0 to n-1. If an invalid index is entered, the message “Error: Invalid image index” (ending with a newline character) is printed and the image distance task is finished. Note that if the image array is empty, all indices will be invalid. For two valid indices imgIndex1 and imgIndex2, the image distance task finds the histograms hist1 and hist2 of images in the nodes cur_node1 and cur_node2 associated with indices imgIndex1 and imgIndex2, respectively. A histogram is an array of 256 integers. The task compu! tes the Euclidean distance between the two vectors corresponding to the histograms. The Euclidean distance is defined as:
dst = sqrt(å0 £ j < 256 (hist1[j]-hist2[j])2).
The task is implemented in a function that returns the Euclidean distance as a double value and prints the message “The distance between image imgIndex1 and image imgIndex2 is dst“ (ending with a newline), where imgIndex1 and imgIndex2 are integers printed with no leading zeros and dst is a double, a floating point number printed with no leading zeros and SIX digits of precision after the decimal point (e.g., 4.487652, 71.873058, 890.239030). After the image distance task is executed, the menu screen is displayed again.
The query image task searches the most similar image in the linked list imgLst to a given query image. Once the user selects the option ‘U’ in the menu screen, the system prompts the user with the message “Enter filename: “ (ending with a space) and reads the filename into a string of characters (i.e., char fileName[80];). You may assume that the user will enter a filename with less than 80 characters. After that, the system prompts the user with the message “Enter threshold value: “(ending with a space) and reads a positive floating point number ths into a type double variable. You will use the function readImage to read the bitmap image and store it in a pointer to unsigned characters. Find the histogram hist1 for the query image and normalize the histogram by dividing it by the size hS*vS of the query image. For each image in a node cur_node of imgLst, find the corresponding histogram hist2 and normalize the histogram by dividing it by the corresponding image ! size. For the normalization, you should copy the histograms to arrays of type double. Use the normalized histograms to compute the distance between the query image and the image in cur_node. Find the image in a node min_node of imgLst with the minimum distance min_dst to the query image. Do not forget to free the space for the query image. If min_dst < ths, print the message “The query image matches image imgIndex“ (ending with a newline), where imgIndex is an integer printed with no leading zeros and corresponds to the index of the node min_node. Otherwise, print the message “No match found” (ending with a newline). After the query image task is executed, the menu screen is displayed again.
The print list task prints the sizes of all images in node of the linked list imgLst. Once the user selects the option ‘S’ in the menu screen, the system just displays the size of each image in a node of imgLst. Each image size is printed as “(vS, hS) “ with a space separating this image size from the next image size. All image sizes are printed in a single line. If the list is empty, a blank line is printed. After the print list task is executed, the menu screen is displayed again.
The quit program task prints the message “Program terminated” (ending with a newline character), clears the memory space used for images in all nodes, deletes the space used for the nodes, and exits the program normally.
4. Implementation Requirements

Global constant for specific values or maximum values should be code with #define or the const declaration.

You should follow structured programming (modularity, no goto commands). The program should not use global variables, exit, break, and continue (except in a switch).

All documentation guidelines suggested in the class webpage should be followed. At least, your program should have a header with your name, the number of the lab assignment, and a description of the program. Each function should also have a header describing the name, purpose, input, and output of the function.

The program should be organized modularly in a set of functions with a main function, a different function for each task, and a function for the menu operations. The menu screen selection should be implemented with a switch. You may use more functions but these are minimally required.

The program must be compiled using gcc and run in the OIT’s Omega system. Programs must compile with no warnings and errors and run without any errors. Labs with compiler warnings or errors and labs that do not terminate normally will receive a zero grade. It is your responsibility to test all possible choices in your program to make sure that none of them cause a runtime error. The goal of creating input test data and running your program with it should be to test all of the various choices in your program to make sure all of them terminate correctly.

5. Deductions

Use of global variables will result in a zero grade.

Use of the exit, break, or continue command will result in a zero grade.

Labs with compiler errors and lab that do not terminate normally will receive a zero grade.

Late submission will result in a 10 point deduction per day and in a zero grade after the third day.

6. Testing Material

A set of bitmap samples is available in the file sampleBitmaps.zip. To test your code, copy these bitmap files to your working directory. The file bitmap.c which defines the function

void readImage(const char *fname, unsigned char **img)

is also included in the testing material. To compile your code lab3.c use the file bitmap.c as follows:

gcc bitmap.c lab3.c –o lab3 –lm.

A set of inputs and outputs are also provided in the files input.zip (input0, input1, input2) and output.zip (output0, output1, output2). To test your code, execute your program using redirection

lab3 < input0 > myoutput0

This command feeds the input inside the file input0 to your program and produces a file name myoutput0 with the output of your program.

You should compare your output (myoutput0) with the one provided in the output.zip file (output0). Use the diff utility in the Omega unix system to check if your output is correct.

diff –B myoutput0 output0

Your output should match exactly the one provided. In this case, the diff utility output is nothing, indicating that your output does not differ from the provided output.

7. Before Submitting

1. You are not supposed to alter bitmap.c. Your code should compile with the bitmap.c provided. You do not have to include bitmap.c or bitmap.h (which does NOT exist) using #include in lab3.c.

2. Test your code with the bitmap files and testing material (input and output). Make sure you use the diff utility to be certain your code is functioning correctly and as expected.

3. Make sure you submit a C source code file (not a renamed executable/object file) named lab3.c (not Lab3.c).